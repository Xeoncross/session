package session

import (
	"crypto/rand"
	"encoding/base64"
	"io"
)

// Based on https://github.com/gorilla/sessions/blob/master/sessions.go

// Default flashes key.
const flashesKey = "_flash"

// NewSession creates a new session instance
func NewSession(length int) *Session {
	return &Session{
		ID:     generateRandomKey(length),
		values: make(map[string]interface{}),
	}
}

// Session stores the values and optional configuration for a session.
type Session struct {
	// The ID of the session, generated by stores. It should not be used for
	// user data.
	ID []byte
	// Values contains the user-data for the session.
	values map[string]interface{}
	// Session changed and should be saved
	changed bool
}

// Base64ID version of ID bytes
func (s *Session) Base64ID() string {
	return EncodeSessionID(s.ID)
}

// Get will return the value or nil
func (s *Session) Get(key string) interface{} {
	if v, ok := s.values[key]; ok {
		return v
	}
	return nil
}

// Set will update or create a new key value
func (s *Session) Set(key string, value interface{}) {
	if v, ok := s.values[key]; ok {
		if v != value {
			s.changed = true
		}
	} else {
		s.changed = true
	}
	s.values[key] = value
}

// Flashes returns a slice of flash messages from the session.
//
// A single variadic argument is accepted, and it is optional: it defines
// the flash key. If not defined "_flash" is used by default.
func (s *Session) Flashes(vars ...string) []interface{} {
	var flashes []interface{}
	key := flashesKey
	if len(vars) > 0 {
		key = vars[0]
	}
	if v, ok := s.values[key]; ok {
		// Drop the flashes and return it.
		delete(s.values, key)
		s.changed = true
		flashes = v.([]interface{})
	}
	return flashes
}

// AddFlash adds a flash message to the session.
//
// A single variadic argument is accepted, and it is optional: it defines
// the flash key. If not defined "_flash" is used by default.
func (s *Session) AddFlash(value interface{}, vars ...string) {
	key := flashesKey
	if len(vars) > 0 {
		key = vars[0]
	}
	var flashes []interface{}
	if v, ok := s.values[key]; ok {
		flashes = v.([]interface{})
	}
	s.values[key] = append(flashes, value)
	s.changed = true
}

// EncodeSessionID in base64 string for cookie
func EncodeSessionID(s []byte) string {
	return base64.URLEncoding.EncodeToString(s)
}

// DecodeSessionID in base64 from cookie
func DecodeSessionID(s string) []byte {
	b, err := base64.URLEncoding.DecodeString(s)
	if err == nil {
		return b
	}
	return nil
}

// GenerateRandomKey creates a random key with the given length in bytes.
// On failure, returns nil.
//
// Callers should explicitly check for the possibility of a nil return, treat
// it as a failure of the system random number generator, and not continue.
func generateRandomKey(length int) []byte {
	k := make([]byte, length)
	if _, err := io.ReadFull(rand.Reader, k); err != nil {
		return nil
	}
	return k
}
